---
title: "Notes on Dates"
author: "Sharon Howard"
description: "Why are dates so hard?"
date-modified: today
categories: 
  - dates
execute: 
  warning: false
  message: false
  echo: false 
---

## Wikibase queries

See the [Dates](https://beyond-notability.wikibase.cloud/wiki/Project:SPARQL/examples#Dates) section of the example queries.

## Notes on some complexities

Dates may be recorded as main values or qualifiers, which need different queries. 

The majority of dates are qualifiers, and there are at least 50 different properties representing events or activities that can be dated.

Main level dates may have one of two different datatypes: "Time" (ymdHMS format) or "EDTF" ([Extended Date/Time Format](https://www.loc.gov/standards/datetime/)) for "fuzzier" dates. Qualifier dates only have Time datatype.

- Time dates are always stored and exported by the wikibase (and handled by R) in year-month-day format, even if they've been recorded at a lower level of precision (eg year only); the precision level is stored separately and has to be specifically queried.  
- EDTF dates are exported as text strings which need to be converted to real dates. So far they've been used in a fairly straightforward way, mirroring the precision levels for Time dates, but they could be much more complex. [This comment is not intended as encouragement.]

For qualifier dates there are five different properties: point in time; start time; end time; earliest date; latest date.
  - a pair of start and end time represents a date range
  - but often only one of start/end is recorded
  - point in time may represent either a discrete short term event or a known moment in what could have been a longer duration
  - latest date can be *very* imprecise
 
Dates may not be recorded at all; some dates are more likely to be recorded than others. Conversely, occasionally there may be more than one recorded date to choose from apart from start/end pairs (or for annoying technical reasons queries return more than one)

There are occasional (apparent) inconsistencies in usage which can be difficult to interpret: eg at time of writing there is one date for the property `married name` (for Olwen Brogan) and it's not clear why this isn't recorded as `married in` instead.


```{r}
# shared libraries, functions etc ####

source(here::here("_R/shared.R"))

# any extra libraries will usually go here 
library(ggbeeswarm)

#library(treemapify)

# standard query strings and queries ####

source(here::here("_R/std_queries.R"))
```


```{r}
## main dates PIT and EDTF

bn_women_dates_main_sparql <-
'SELECT distinct ?person ?personLabel ?date_prop_label ?date_pit ?date_pit_precision   ?date_edtf  ?date_prop  ?s

WHERE {
 
 { # PIT 
   
   ?person bnwdt:P3 bnwd:Q3 . #select women
   FILTER NOT EXISTS { ?person bnwdt:P4 bnwd:Q12 . } 
      
   ?person ?p ?s .   
      ?date_prop wikibase:claim ?p;     	 
         wikibase:statementValue ?psv .  
      ?date_prop wikibase:propertyType wikibase:Time . # for PIT only. 
      ?date_prop rdfs:label ?date_prop_label. filter(lang(?date_prop_label)="en-gb") . 
   
  # get dates detail via ?s and psv
      ?s ?psv ?wdv .
        ?wdv wikibase:timeValue ?date_pit ;
           wikibase:timePrecision ?date_pit_precision .

   }
  
  union
  
  { # EDTF
  
    ?person bnwdt:P3 bnwd:Q3 . 
       FILTER NOT EXISTS { ?person bnwdt:P4 bnwd:Q12 . } 
     
       ## can do this union first but makes no difference to results except possibly a bit slower.
       #?person ( bnp:P131 | bnp:P132 | bnp:P133  ) ?s .
       #   ?s ( bnps:P131 | bnps:P132 | bnps:P133  ) ?date_edtf .

       ?person ?p ?s . # so you can get the statement id and date prop label
           ?claim wikibase:claim ?p;       
                 rdfs:label ?date_prop_label. filter(lang(?date_prop_label)="en") .        

           ?s ?date_prop ?date_edtf . # cant name this date again. 
              
    ## filter for edtf dates
    ## docs: https://github.com/ProfessionalWiki/WikibaseEdtf
    ## cant see any way other than a filter to get the edtf value.
    FILTER ( datatype(?date_edtf) = xsd:edtf  ) .
   }
  
 SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en-gb,en". } 
  
} # /where

ORDER BY ?person ?date_value ?date_edtf
'


bn_women_dates_main_query <-
  bn_std_query(bn_women_dates_main_sparql) |>
  make_bn_item_id(person)  |>
  make_bn_ids(c(s, date_prop)) |>
  mutate(across(c(date_prop_label, date_pit, date_edtf), ~na_if(., ""))) |>
  #make_date_year() |> # leave this to the next stage.
  relocate(person, .after = last_col())





# revised qualifiers. needs bnpqv prefix...
# revised again: fetch both simple date value and timevalue and then need to dedup by filtering
bn_women_dates_qual_sparql <-
'SELECT distinct ?person ?personLabel ?prop_label ?prop_valueLabel ?date_qual_label  ?date_qual ?date_qual_precision ?date_qual_simple ?prop_value ?prop ?s

WHERE {
     #VALUES (?person) {(bnwd:Q106) (bnwd:Q1675)}  # for testing 
    ?person bnwdt:P3 bnwd:Q3 . # women
    FILTER NOT EXISTS { ?person bnwdt:P4 bnwd:Q12 . } 
  
    # get stuff about ?person   
    ?person ?p ?s .   
  
      # the claim for ?p .  do i need psv as well as ps?
      ?prop wikibase:claim ?p;      
         wikibase:statementProperty ?ps;     
         wikibase:statementValue ?psv.
      ?prop rdfs:label ?prop_label. filter(lang(?prop_label)="en") .  # spoke at etc
 
  # the direct value (usually item) for the property, things like annual meeting, girton college. .
        ?s ?ps ?prop_value.
     
  # get date qualifiers. [assumes no edtf in quals. ]
        ?s ?pq ?date_qual_simple .  # this causes dups but need to get the label
          ?qual_prop wikibase:qualifier ?pq .
          ?qual_prop wikibase:propertyType wikibase:Time. 
          ?qual_prop rdfs:label ?date_qual_label . filter(lang(?date_qual_label)="en") . 

  # qualifier timevalue and precision. requires the bnpqv: prefix; i dont know how to do it without specifying them. 
  # pit/start/end/earliest/latest - anything else?
      ?s (bnpqv:P1 | bnpqv:P27 | bnpqv:P28 | bnpqv:P51 | bnpqv:P53 ) ?pqv.
          ?pqv wikibase:timeValue ?date_qual .  
          ?pqv wikibase:timePrecision ?date_qual_precision .
      
 SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en, en-gb". } 
  
} # /where

ORDER BY ?personLabel ?s ?prop_label'



# still slooow. 
# since the query is pretty slow and you might want to be able to check the unfiltered version, let's do this in two steps...
bn_women_dates_qual_query_unfiltered <-
  bn_std_query(bn_women_dates_qual_sparql) |>
  make_bn_item_id(person) |> 
  make_bn_ids(c(prop, prop_value, s)) |>
  relocate(person, .after = last_col())

# **fudge to get rid of nasty dups** i THINK it works. it is possible to do this filter inside the query so i might update once i'm sure it works, if i don't find a proper way to do it.
bn_women_dates_qual_query <-
  bn_women_dates_qual_query_unfiltered |>
  filter(date_qual==date_qual_simple) |>
  select(-date_qual_simple)

# pretty sure these queries drop <uv> dates. but might not always be the case
# qual prop value can contain stuff other than Qs

```



```{r}
bn_women_dates_main <-
bn_women_dates_main_query  |>
  # in case there are any <uv>, and keep the original.
  mutate(date_pit_parsed = if_else(str_detect(date_pit, "t"), NA, date_pit))  |>
  mutate(date_pit_parsed = parse_date_time(date_pit_parsed, "ymdHMS"))  |>
  mutate(date_edtf_parsed = parse_date_time(date_edtf, c("ymd", "ym", "y")) ) |>
  # make single date / year column. 
  mutate(date = if_else(!is.na(date_pit_parsed), date_pit_parsed, date_edtf_parsed)) |>
  mutate(year = year(date)) |>
  # do this after parsing and consolidating pit/edtf, dummy
  mutate(date_string = case_when(
           date_pit_precision==11 ~  as.character(date),
           date_pit_precision==10 ~ str_replace(as.character(date), "-01$", "-00"),
           date_pit_precision==9 | str_length(date_edtf)==4 ~ paste0(year, "-00-00"),
           str_length(date_edtf)==10 ~ date_edtf,
           str_length(date_edtf)==7 ~ paste0(date_edtf, "-00")
        ) ) |>
  mutate(date_precision = case_when(
    date_pit_precision==11 | str_length(date_edtf)==10 ~ "ymd",
    date_pit_precision==10 | str_length(date_edtf)==7 ~ "ym",
    date_pit_precision==9 | str_length(date_edtf)==4 ~ "y",
  )) |>
  # use case_when in case you need to do anything different with <uv> pit dates at some point
  mutate(date_format = case_when(
    !is.na(date_pit) ~ "point in time", 
    !is.na(date_edtf) ~ "edtf"
    )) |>
  mutate(date_type = "main") |>
  relocate(date, year, date_precision, date_format, date_type, date_string, .after = date_prop_label) |>
  relocate(date_pit:date_edtf, .after = person)
  


bn_women_dates_qual <-
bn_women_dates_qual_query |>
    mutate(date = if_else(str_detect(date_qual, "t"), NA, date_qual))  |> # shouldn't be any of these actually!
    mutate(date = parse_date_time(date, "ymdHMS"))  |>
    mutate(year = year(date)) |>
  mutate(date_string = case_when(
           date_qual_precision==11 ~  as.character(date),
           date_qual_precision==10 ~ str_replace(as.character(date), "-\\d\\d$", "-00"),
           date_qual_precision==9 ~ paste0(year, "-00-00")
        ) ) |>
  mutate(date_precision = case_when(
    date_qual_precision==11  ~ "ymd",
    date_qual_precision==10 ~ "ym",
    date_qual_precision==9 ~ "y",
  )) |>
  # just rename rather than make dup column
  rename(date_format = date_qual_label) |>
  mutate(date_type = "qual") |>
  relocate(date, year, date_precision, date_format, date_type, date_string, .after = personLabel) |>
  # remove AT recorded by dates. should i ask about these? i suspect not current practice and they're awkward.
  # keep na for now, check them.
  filter(year < 2020 | is.na(year))


bn_women_dates <-
  bind_rows(
  bn_women_dates_main |> select(-date_pit:-date_edtf_parsed) ,
  bn_women_dates_qual |> select(-date_qual, -date_qual_precision) |>
    rename(date_prop=prop, date_prop_label= prop_label)
)  |>
  relocate(prop_valueLabel, .after = date_prop_label) |>
  relocate(prop_value, .after = date_prop) |>
  arrange(bn_id)

bn_women_dates_death <-
bn_women_dates |>
  filter(date_prop %in% c("P15")) |>
  #add_count(bn_id) |> filter(n>1) |>
  group_by(bn_id) |>
  arrange(date_precision, .by_group = TRUE) |>
  top_n(1, row_number()) |>
  ungroup()

bn_women_dates_birth <-
bn_women_dates |>
  filter(date_prop %in% c("P26")) |>
  #add_count(bn_id) |> filter(n>1) |>
    group_by(bn_id) |>
  arrange(date_precision, .by_group = TRUE) |>
  top_n(1, row_number()) |>
  ungroup()


# all dates for women who have both DOB and DOD, hopefully in the right order
bn_women_dates_birth_death <-
bind_rows(
  bn_women_dates_birth,
  bn_women_dates_death
) |>
  add_count(bn_id) |>
  filter(n==2) |>
  arrange(bn_id) |>
  select(bn_id, date_prop_label, year) |>
  pivot_wider(names_from = date_prop_label, values_from = year) |>
  clean_names("snake") |>
  rename(year_birth=date_of_birth, year_death=date_of_death) |>
  left_join(
    bn_women_dates |>
      filter(!date_prop %in% c("P15", "P26")) |>
      bind_rows(bn_women_dates_birth, bn_women_dates_death) , by="bn_id"
  ) |>
  group_by(bn_id) |>
  arrange(year, date, .by_group = TRUE) |>
  # tweaks to ensure birth date is always 1 and death date is always last...
  # occasional date like resided is same year as birth and sorting can get buggered up. so assume similar things could happen with death
  mutate(bn_date_id=row_number()+1, l=last(bn_date_id)) |>
  ungroup() |>
  mutate(bn_date_id = case_when(
    date_prop_label=="date of birth" ~ 1,
    date_prop_label=="date of death" ~ l+1,
    .default = bn_date_id
  )) |>
  arrange(bn_id, bn_date_id) |>
  # now redo the numbering
  group_by(bn_id) |>
  mutate(bn_date_id = row_number()) |>
  ungroup() |>
  select(-l) |>
  relocate(bn_date_id, .after = bn_id) 

```


```{r}
# to make a palette for use in scale_colour_manual: top 9 values are in colour, then the rest are grey.
# need the set without grey for the table  

pal9 <- c( '#CC6677', '#332288', '#F67E4B', '#117733', '#0077BB', '#882255', '#44AA99', '#999933', '#AA4499' )

pal9_light <- c('#EE3377','#77AADD', '#EE8866', '#EEDD88',  '#99DDFF','#FFAABB', '#44BB99', '#BBCC33',  '#AAAA00')

pal8_light <- c('#77AADD', '#EE8866', '#EEDD88',  '#99DDFF','#FFAABB', '#44BB99', '#BBCC33',  '#AAAA00')

pal9df <- 
  c(pal8_light, '#dddddd') |>
  enframe()

# pal10df <- 
#   c(pal9, '#dddddd') |>
#   enframe()
# 
# pal10df_light <- 
#   c(pal9_light, '#dddddd') |>
#   enframe()

make_palette <-
bn_women_dates_birth_death |>
  count(date_prop_label) |>
  # make date of birth and date of death NA
  mutate(n = if_else(date_prop_label %in% c("date of birth", "date of death"), NA, n)) |>
  # now they sort to the end of the table
  arrange(-n) |>
  # so they're excluded from top row numbers
  rowid_to_column() |>
  left_join(pal9df, by=c("rowid"="name")) |>
  # set colour you want for date of birth/death separately
  mutate(value=if_else(date_prop_label %in% c("date of birth", "date of death"), "#bbbbbb", value)) |>
  # and now you can fill the rest with lighter grey... 
  fill(value) |>
  select(date_prop_label, value) |>
  # turn the df into a named vector with deframe and this can be used in scale_color_manual
  deframe()

# and get the names back into a table again for display
coloured_props <-
make_palette |>
  enframe() |>
  select(name) |>
  head(8)
```


## Experimental visualisations


### Beeswarm plots of activity by age

- every date is a single point
- only women who have both birth and death dates
- split women up into three groups by birth date between 1825 and 1914 (there are only a few women before/after those dates) 
- birth at 0 is not shown; death is coloured grey; the top eight properties apart from those two are highlighted in colour and the rest are shown but in very light grey [second version will do colours in a more rational manner, hopefully]

```{r}
bn_women_dates_birth_death |>
  filter(between(year_birth, 1825, 1914)) |>
  filter(date_prop_label != "date of birth") |>
  mutate(age = year-year_birth) |>
  mutate(period = case_when(
    between(year_birth, 1825, 1854) ~ "1825-1854",
    between(year_birth, 1855, 1879) ~ "1855-1879",
    between(year_birth, 1880, 1914) ~ "1880-1914"
  )) |>
  filter(date_prop_label !="date of birth") |>
  #mutate(period = fct_rev(period)) |>
  ggplot(aes(period, age, colour=date_prop_label)) +
  geom_beeswarm(size=1, show.legend = F) +
#  geom_quasirandom(orientation = "y") +
  #scale_color_ptol() +
  scale_colour_manual(values = make_palette) +
  #theme(legend.position = "bottom", aspect.ratio = 5/4) +
  labs(y=NULL, x="birth period")
```

Colour key

```{r}
coloured_props |>
  kable() |>
  kable_styling() |>
  column_spec(1, color = "white" , background = pal8_light
              )
```


## Table

This should contain every recorded date for every woman who has both birth and death dates... hopefully in the correct chronological order. 

Start and end times in the same year may not currently always be correctly sorted. More generally, it can be difficult to ensure that dates in the same year but with low or different precision levels come out in the desired order (or even to decide what the desired order in those cases should be).

A year-only date should display as 01/01/year but in some cases below the software package used to render the table is displaying them as 31/12 of the *previous* year, and I have no idea why: the underlying data is fine. (It may only affect certain dates.) I'll work out how to fix it. 

```{r}
reactable(
  bn_women_dates_birth_death |>
  select(-person, -bn_date_id, -year_birth, -year_death, -date_string, -prop_value, -s) ,
  filterable = TRUE,
  searchable = TRUE,
  bordered = TRUE,
  highlight = TRUE,
  defaultPageSize = 100,
  groupBy = c("bn_id", "personLabel"),
  defaultExpanded = TRUE,
  defaultColDef = colDef(maxWidth = 150),  # , headerClass = "sticky" but i think it has to be fixed height to use this
  columns = list(
    #bn_id = colDef(name="id", maxWidth = 75),
    bn_id = colDef(show = FALSE),
    date_prop = colDef(show=FALSE),
    personLabel =colDef(maxWidth = 200, name="name" #,
      # html = TRUE,
      # cell = function(value, index) {
      #   sprintf('<a href="%s" target="_blank">%s</a>', bn_women_dates_birth_death$person[index], value)
      # }
      )   ,
    date_prop_label = colDef(maxWidth = 120, name="property",
      html = TRUE,
      cell = function(value, index) {
        sprintf('<a href="%s" target="_blank">%s</a>', paste(bn_women_dates_birth_death$person[index], bn_women_dates_birth_death$date_prop[index], sep="#"), value)
      }),
    date_precision = colDef(maxWidth = 100, name="precision"),
    prop_valueLabel = colDef(name="qual value", maxWidth = 180),
    date = colDef(format = colFormat(date=TRUE), minWidth = 120),
   date_type = colDef(name="type", maxWidth = 90),
   date_format = colDef(name="format", maxWidth = 100),
   year = colDef(maxWidth = 90)
  )
)
```




